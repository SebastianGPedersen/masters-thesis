hv <- 1500*dt
conf = 0.95
mu<-est.mu.next(data = data, hd = hd, t.index = tind)
sig <- est.sigma.next(data, hv=hv, t.index = tind, lag = 15)
# Calculate T
Tstat<-teststat(mu, sig, hd, hv)
# Calculate T*
Tstar<-tstar(Tstat)$tstar
# fit rho
rho <- est.rho(Tstat$test)
z<-est.z_quantile(rho$m, rho$rho, conf)$qZm
res<-Tstar>=z
a<-c(res, Tstar, z)
names(a) <- c("T/F", "Tstar", "z")
print(a)
plot(Tstat$test, type = "l")
}
setwd(Sys.getenv("masters-thesis"))
source("estimation/estimates.R")
source("estimation/rho.R")
source("estimation/teststat.R")
source("estimation/pre-average.R")
source("kernels/kernels.R")
# SIM BS
sim<-function(spot, mean = 0, sd = 0.015, noise = 1/100000, t = 0:20000, mat = 6.5/(24*7*52), N = 1){
# runs the testfun(ction) N times and returns mean/var/values/(plot)
# sd is multiplied by sqrt(dt)
dt <- mat/t[length(t)]
out <- numeric(N)
for(i in 1:N)
{
x <- c(log(spot),rnorm(length(t)-1 , mean = mean*dt, sd = sd*sqrt(dt)))
eps <- rnorm(length(t), mean = 0, sd = noise)
x <- cumsum(x)
y <- x + eps
data<-data.frame(time = t*dt, Y = y)
}
return(data)
}
set.seed(2342)
spot <- 100
mean <- 0.05
sig <- 0.15
noise <- 0.1
t <- 0:20000
mat <- 6.5/(24*7*52)
sims <- sim(spot = spot, mean = mean, sd = sig, noise = noise, t = t, mat = mat, N = 1)
#plot(sims$Y, type = "l")
# go!
{
k <- 1*152#1*sqrt(length(sims$time))
prev <- c(rep(0,k-2),est.PreAverage(sims$Y, k)) # Kim does not divide by k - scaling does not change results
tind <- seq(from = 1000, to = 19000, by = 10)
data <- list(time = sims$time*1*52*7*24*60*60*1000, Y = prev)
#plot(data$Y, type ="l")
dt <- diff(data$time)[1]
hd <- 300*dt
hv <- 1500*dt
conf = 0.95
mu<-est.mu.next(data = data, hd = hd, t.index = tind)
sig <- est.sigma.next(data, hv=hv, t.index = tind, lag = 15)
# Calculate T
Tstat<-teststat(mu, sig, hd, hv)
# Calculate T*
Tstar<-tstar(Tstat)$tstar
# fit rho
rho <- est.rho(Tstat$test)
z<-est.z_quantile(rho$m, rho$rho, conf)$qZm
res<-Tstar>=z
a<-c(res, Tstar, z)
names(a) <- c("T/F", "Tstar", "z")
print(a)
plot(Tstat$test, type = "l")
}
setwd(Sys.getenv("masters-thesis"))
source("estimation/estimates.R")
source("estimation/rho.R")
source("estimation/teststat.R")
source("estimation/pre-average.R")
source("kernels/kernels.R")
# SIM BS
sim<-function(spot, mean = 0, sd = 0.015, noise = 1/100000, t = 0:20000, mat = 6.5/(24*7*52), N = 1){
# runs the testfun(ction) N times and returns mean/var/values/(plot)
# sd is multiplied by sqrt(dt)
dt <- mat/t[length(t)]
out <- numeric(N)
for(i in 1:N)
{
x <- c(log(spot),rnorm(length(t)-1 , mean = mean*dt, sd = sd*sqrt(dt)))
eps <- rnorm(length(t), mean = 0, sd = noise)
x <- cumsum(x)
y <- x + eps
data<-data.frame(time = t*dt, Y = y)
}
return(data)
}
set.seed(2342)
spot <- 100
mean <- 0.05
sig <- 0.15
noise <- 0.1
t <- 0:20000
mat <- 6.5/(24*7*52)
sims <- sim(spot = spot, mean = mean, sd = sig, noise = noise, t = t, mat = mat, N = 1)
#plot(sims$Y, type = "l")
# go!
{
k <- 1*152#1*sqrt(length(sims$time))
prev <- c(rep(0,k-2),est.PreAverage(sims$Y, k)) # Kim does not divide by k - scaling does not change results
tind <- seq(from = 1000, to = 19000, by = 10)
data <- list(time = sims$time*1*52*7*24*60*60*1000, Y = prev)
#plot(data$Y, type ="l")
dt <- diff(data$time)[1]
hd <- 300*dt
hv <- 1500*dt
conf = 0.95
mu<-est.mu.next(data = data, hd = hd, t.index = tind)
sig <- est.sigma.next(data, hv=hv, t.index = tind, lag = 15)
# Calculate T
Tstat<-teststat(mu, sig, hd, hv)
# Calculate T*
Tstar<-tstar(Tstat)$tstar
# fit rho
rho <- est.rho(Tstat$test)
z<-est.z_quantile(rho$m, rho$rho, conf)$qZm
res<-Tstar>=z
a<-c(res, Tstar, z)
names(a) <- c("T/F", "Tstar", "z")
print(a)
plot(Tstat$test, type = "l")
}
qqnorm(Tstat$test)
mean(Tstat$test)
var(Tstat$test)
setwd(Sys.getenv("masters-thesis"))
source("estimation/estimates.R")
source("estimation/rho.R")
source("estimation/teststat.R")
source("estimation/pre-average.R")
source("kernels/kernels.R")
# SIM BS
sim<-function(spot, mean = 0, sd = 0.015, noise = 1/100000, t = 0:20000, mat = 6.5/(24*7*52), N = 1){
# runs the testfun(ction) N times and returns mean/var/values/(plot)
# sd is multiplied by sqrt(dt)
dt <- mat/t[length(t)]
out <- numeric(N)
for(i in 1:N)
{
x <- c(log(spot),rnorm(length(t)-1 , mean = mean*dt, sd = sd*sqrt(dt)))
eps <- rnorm(length(t), mean = 0, sd = noise)
x <- cumsum(x)
y <- x + eps
data<-data.frame(time = t*dt, Y = y)
}
return(data)
}
set.seed(2342)
spot <- 100
mean <- 0.05
sig <- 0.15
noise <- 0.1
t <- 0:20000
mat <- 6.5/(24*7*52)
sims <- sim(spot = spot, mean = mean, sd = sig, noise = noise, t = t, mat = mat, N = 1)
#plot(sims$Y, type = "l")
# go!
{
k <- 1*152#1*sqrt(length(sims$time))
prev <- c(rep(0,k-2),est.PreAverage(sims$Y, k)) # Kim does not divide by k - scaling does not change results
tind <- seq(from = 1000, to = 19000, by = 10)
data <- list(time = sims$time*1*52*7*24*60*60*1000, Y = prev)
#plot(data$Y, type ="l")
dt <- diff(data$time)[1]
hd <- 300*dt
hv <- 1500*dt
conf = 0.95
mu<-est.mu.next(data = data, hd = hd, t.index = tind)
sig <- est.sigma.next(data, hv=hv, t.index = tind, lag = 15)
# Calculate T
Tstat<-teststat(mu, sig, hd, hv)
# Calculate T*
Tstar<-tstar(Tstat)$tstar
# fit rho
rho <- est.rho(Tstat$test)
z<-est.z_quantile(rho$m, rho$rho, conf)$qZm
res<-Tstar>=z
a<-c(res, Tstar, z)
names(a) <- c("T/F", "Tstar", "z")
print(a)
plot(Tstat$test, type = "l")
}
qqnorm(Tstat$test)
mean(Tstat$test)
var(Tstat$test)
setwd(Sys.getenv("masters-thesis"))
source("estimation/estimates.R")
source("estimation/rho.R")
source("estimation/teststat.R")
source("estimation/pre-average.R")
source("kernels/kernels.R")
# SIM BS
sim<-function(spot, mean = 0, sd = 0.015, noise = 1/100000, t = 0:20000, mat = 6.5/(24*7*52), N = 1){
# runs the testfun(ction) N times and returns mean/var/values/(plot)
# sd is multiplied by sqrt(dt)
dt <- mat/t[length(t)]
out <- numeric(N)
for(i in 1:N)
{
x <- c(log(spot),rnorm(length(t)-1 , mean = mean*dt, sd = sd*sqrt(dt)))
eps <- rnorm(length(t), mean = 0, sd = noise)
x <- cumsum(x)
y <- x + eps
data<-data.frame(time = t*dt, Y = y)
}
return(data)
}
set.seed(2342)
spot <- 100
mean <- 0.05
sig <- 0.15
noise <- 0.00001#0.1
t <- 0:20000
mat <- 6.5/(24*7*52)
sims <- sim(spot = spot, mean = mean, sd = sig, noise = noise, t = t, mat = mat, N = 1)
#plot(sims$Y, type = "l")
# go!
{
k <- 1*152#1*sqrt(length(sims$time))
prev <- c(rep(0,k-2),est.PreAverage(sims$Y, k)) # Kim does not divide by k - scaling does not change results
tind <- seq(from = 1000, to = 19000, by = 10)
data <- list(time = sims$time*1*52*7*24*60*60*1000, Y = prev)
#plot(data$Y, type ="l")
dt <- diff(data$time)[1]
hd <- 300*dt
hv <- 1500*dt
conf = 0.95
mu<-est.mu.next(data = data, hd = hd, t.index = tind)
sig <- est.sigma.next(data, hv=hv, t.index = tind, lag = 15)
# Calculate T
Tstat<-teststat(mu, sig, hd, hv)
# Calculate T*
Tstar<-tstar(Tstat)$tstar
# fit rho
rho <- est.rho(Tstat$test)
z<-est.z_quantile(rho$m, rho$rho, conf)$qZm
res<-Tstar>=z
a<-c(res, Tstar, z)
names(a) <- c("T/F", "Tstar", "z")
print(a)
plot(Tstat$test, type = "l")
}
setwd(Sys.getenv("masters-thesis"))
source("estimation/estimates.R")
source("estimation/rho.R")
source("estimation/teststat.R")
source("estimation/pre-average.R")
source("kernels/kernels.R")
# SIM BS
sim<-function(spot, mean = 0, sd = 0.015, noise = 1/100000, t = 0:20000, mat = 6.5/(24*7*52), N = 1){
# runs the testfun(ction) N times and returns mean/var/values/(plot)
# sd is multiplied by sqrt(dt)
dt <- mat/t[length(t)]
out <- numeric(N)
for(i in 1:N)
{
x <- c(log(spot),rnorm(length(t)-1 , mean = mean*dt, sd = sd*sqrt(dt)))
eps <- rnorm(length(t), mean = 0, sd = noise)
x <- cumsum(x)
y <- x + eps
data<-data.frame(time = t*dt, Y = y)
}
return(data)
}
set.seed(2342)
spot <- 100
mean <- 0.05
sig <- 10.15
noise <- 0.00001#0.1
t <- 0:20000
mat <- 6.5/(24*7*52)
sims <- sim(spot = spot, mean = mean, sd = sig, noise = noise, t = t, mat = mat, N = 1)
#plot(sims$Y, type = "l")
# go!
{
k <- 1*152#1*sqrt(length(sims$time))
prev <- c(rep(0,k-2),est.PreAverage(sims$Y, k)) # Kim does not divide by k - scaling does not change results
tind <- seq(from = 1000, to = 19000, by = 10)
data <- list(time = sims$time*1*52*7*24*60*60*1000, Y = prev)
#plot(data$Y, type ="l")
dt <- diff(data$time)[1]
hd <- 300*dt
hv <- 1500*dt
conf = 0.95
mu<-est.mu.next(data = data, hd = hd, t.index = tind)
sig <- est.sigma.next(data, hv=hv, t.index = tind, lag = 15)
# Calculate T
Tstat<-teststat(mu, sig, hd, hv)
# Calculate T*
Tstar<-tstar(Tstat)$tstar
# fit rho
rho <- est.rho(Tstat$test)
z<-est.z_quantile(rho$m, rho$rho, conf)$qZm
res<-Tstar>=z
a<-c(res, Tstar, z)
names(a) <- c("T/F", "Tstar", "z")
print(a)
plot(Tstat$test, type = "l")
}
#qqnorm(Tstat$test)
#mean(Tstat$test)
#var(Tstat$test)
setwd(Sys.getenv("masters-thesis"))
source("estimation/estimates.R")
source("estimation/rho.R")
source("estimation/teststat.R")
source("estimation/pre-average.R")
source("kernels/kernels.R")
# SIM BS
sim<-function(spot, mean = 0, sd = 0.015, noise = 1/100000, t = 0:20000, mat = 6.5/(24*7*52), N = 1){
# runs the testfun(ction) N times and returns mean/var/values/(plot)
# sd is multiplied by sqrt(dt)
dt <- mat/t[length(t)]
out <- numeric(N)
for(i in 1:N)
{
x <- c(log(spot),rnorm(length(t)-1 , mean = mean*dt, sd = sd*sqrt(dt)))
eps <- rnorm(length(t), mean = 0, sd = noise)
x <- cumsum(x)
y <- x + eps
data<-data.frame(time = t*dt, Y = y)
}
return(data)
}
set.seed(2342)
spot <- 100
mean <- 0.05
sig <- 0.15
noise <- 0.1#0.1
t <- 0:20000
mat <- 6.5/(24*7*52)
sims <- sim(spot = spot, mean = mean, sd = sig, noise = noise, t = t, mat = mat, N = 1)
#plot(sims$Y, type = "l")
# go!
{
k <- 1*152#1*sqrt(length(sims$time))
prev <- c(rep(0,k-2),est.PreAverage(sims$Y, k)) # Kim does not divide by k - scaling does not change results
tind <- seq(from = 1000, to = 19000, by = 10)
data <- list(time = sims$time*1*52*7*24*60*60*1000, Y = prev)
#plot(data$Y, type ="l")
dt <- diff(data$time)[1]
hd <- 300*dt
hv <- 1500*dt
conf = 0.95
mu<-est.mu.next(data = data, hd = hd, t.index = tind)
sig <- est.sigma.next(data, hv=hv, t.index = tind, lag = 15)
# Calculate T
Tstat<-teststat(mu, sig, hd, hv)
# Calculate T*
Tstar<-tstar(Tstat)$tstar
# fit rho
rho <- est.rho(Tstat$test)
z<-est.z_quantile(rho$m, rho$rho, conf)$qZm
res<-Tstar>=z
a<-c(res, Tstar, z)
names(a) <- c("T/F", "Tstar", "z")
print(a)
plot(Tstat$test, type = "l")
}
#qqnorm(Tstat$test)
#mean(Tstat$test)
#var(Tstat$test)
plot(sims$Y, type = "l")
setwd(Sys.getenv("masters-thesis"))
source("estimation/estimates.R")
source("estimation/rho.R")
source("estimation/teststat.R")
source("estimation/pre-average.R")
source("kernels/kernels.R")
# SIM BS
sim<-function(spot, mean = 0, sd = 0.015, noise = 1/100000, t = 0:20000, mat = 6.5/(24*7*52), N = 1){
# runs the testfun(ction) N times and returns mean/var/values/(plot)
# sd is multiplied by sqrt(dt)
dt <- mat/t[length(t)]
out <- numeric(N)
for(i in 1:N)
{
x <- c(log(spot),rnorm(length(t)-1 , mean = mean*dt, sd = sd*sqrt(dt)))
eps <- rnorm(length(t), mean = 0, sd = noise)
x <- cumsum(x)
y <- x + eps
data<-data.frame(time = t*dt, Y = y)
}
return(data)
}
set.seed(2342)
spot <- 100
mean <- 0.05
sig <- 0.15
noise <- 0.00001#0.1
t <- 0:20000
mat <- 6.5/(24*7*52)
sims <- sim(spot = spot, mean = mean, sd = sig, noise = noise, t = t, mat = mat, N = 1)
#plot(sims$Y, type = "l")
# go!
{
k <- 1*152#1*sqrt(length(sims$time))
prev <- c(rep(0,k-2),est.PreAverage(sims$Y, k)) # Kim does not divide by k - scaling does not change results
tind <- seq(from = 1000, to = 19000, by = 10)
data <- list(time = sims$time*1*52*7*24*60*60*1000, Y = prev)
#plot(data$Y, type ="l")
dt <- diff(data$time)[1]
hd <- 300*dt
hv <- 1500*dt
conf = 0.95
mu<-est.mu.next(data = data, hd = hd, t.index = tind)
sig <- est.sigma.next(data, hv=hv, t.index = tind, lag = 15)
# Calculate T
Tstat<-teststat(mu, sig, hd, hv)
# Calculate T*
Tstar<-tstar(Tstat)$tstar
# fit rho
rho <- est.rho(Tstat$test)
z<-est.z_quantile(rho$m, rho$rho, conf)$qZm
res<-Tstar>=z
a<-c(res, Tstar, z)
names(a) <- c("T/F", "Tstar", "z")
print(a)
plot(Tstat$test, type = "l")
}
plot(sims$Y, type = "l")
setwd(Sys.getenv("masters-thesis"))
source("simulation/heston.R")
source("simulation/bursts.R")
source("estimation/estimates.R")
source("estimation/rho.R")
source("estimation/teststat.R")
source("estimation/pre-average.R")
source("kernels/kernels.R")
source("SPY/datafunctions.R")
# IMPORT REAL DATA
fullData<-readRDS(paste0(Sys.getenv("masters-thesis-data"),"/SPY/2014_SPY_Vol_Avg.rds"))
firstDay<-selectDays(fullData, as.Date("2014-05-05"), nDays = 1)
# A QUICK VIEW OF DATA
plot(firstDay$logPrice, type="l")
# GLUE DATA TO FRAME AND FIND TIME INDEX FOR ESTIMATION
data <- list(time = firstDay$Time, Y = firstDay$logPrice)
tind<-timePoints(firstDay, timeOffset = 120, initialDelay = 600)
tind<-tind[1:(length(tind)-1)] # We dont know DY in the latest, do we?
# PRE AVERAGE
horizon<-floor(1*sqrt(length(data$time))) # FORCE INTEGER
k = horizon + (horizon%%2) # FORCE EVEN
prev <- c(rep(0,k-2),est.PreAverage(data$Y, k)) # Kim does not divide by k - scaling does not change results
data <- list(time = data$time, Y = prev)
# BANDWIDTH
dt <- diff(data$time)[1]
hd <- 300*dt
hv <- 1500*dt
conf = 0.95
# Estimation of mu/sig
mu<-est.mu.next(data = data, hd = hd, t.index = tind)
sig <- est.sigma.next(data, hv=hv, t.index = tind, lag = 15)#"auto")
# Calculate T
Tstat<-teststat(mu, sig, hd, hv)
# Calculate T*
Tstar<-tstar(Tstat)$tstar
# fit rho
rho <- est.rho(Tstat$test)
z<-est.z_quantile(rho$m, rho$rho, conf)$qZm
res<-Tstar>=z
a<-c(res, Tstar, z)
names(a) <- c("T/F", "Tstar", "z")
print(a)
plot(Tstat$test, type = "l")
mean(Tstat$test)
var(Tstat$test)
qqnorm(Tstat$test)
fullData<-readRDS(paste0(Sys.getenv("masters-thesis-data"),"/SPY/2014_SPY_Vol_Avg.rds"))
firstDay<-selectDays(fullData, as.Date("2014-06-05"), nDays = 1)
# A QUICK VIEW OF DATA
plot(firstDay$logPrice, type="l")
# GLUE DATA TO FRAME AND FIND TIME INDEX FOR ESTIMATION
data <- list(time = firstDay$Time, Y = firstDay$logPrice)
tind<-timePoints(firstDay, timeOffset = 120, initialDelay = 600)
tind<-tind[1:(length(tind)-1)] # We dont know DY in the latest, do we?
# PRE AVERAGE
horizon<-floor(1*sqrt(length(data$time))) # FORCE INTEGER
k = horizon + (horizon%%2) # FORCE EVEN
prev <- c(rep(0,k-2),est.PreAverage(data$Y, k)) # Kim does not divide by k - scaling does not change results
data <- list(time = data$time, Y = prev)
# BANDWIDTH
dt <- diff(data$time)[1]
hd <- 300*dt
hv <- 1500*dt
conf = 0.95
# Estimation of mu/sig
mu<-est.mu.next(data = data, hd = hd, t.index = tind)
sig <- est.sigma.next(data, hv=hv, t.index = tind, lag = 15)#"auto")
# Calculate T
Tstat<-teststat(mu, sig, hd, hv)
# Calculate T*
Tstar<-tstar(Tstat)$tstar
# fit rho
rho <- est.rho(Tstat$test)
z<-est.z_quantile(rho$m, rho$rho, conf)$qZm
res<-Tstar>=z
a<-c(res, Tstar, z)
names(a) <- c("T/F", "Tstar", "z")
print(a)
plot(Tstat$test, type = "l")
mean(Tstat$test)
var(Tstat$test)
qqnorm(Tstat$test)
