#simulate brownian motion with noise
x <- rnorm(n = length(t) , mean = 0, sd = sqrt(sig2*dt))
x <- cumsum(x)
eps <- simAR(length(t), rho, sqrt(omega2))
#eps <- rnorm(n = length(t), mean = 0, sd = sqrt(omega2))
y <- x + eps
#put in data.frame for use in est.mu function
dataY<-data.frame(time = t*dt, Y = y)
#Get sigma estimates (vigtigt at bandwidth er rigtig lille)
mu[i] <- est.mu(dataY, hd, kern.leftexp, t.index = (length(t)-1))$mu[1] #Take out a random timeindex (9000)
sigmaEst[i] <- est.sigma(data = dataY, hv = hv, kern = kern.leftexp, wkern = kern.parzen,t.index = (length(t)-1),lag=15)$sig
}
C2 <- ksq/2*(2*omega2/(1-rho^2))*(1-rho)/(1+rho)
estT<-sqrt(hd)*sqrt(hv)*(mu/sqrt(sigmaEst)) #Giver Varians på én, rimelig præcist
estSig <- dt/hv*sigmaEst/C2
estMu <- sqrt(dt*hd)*mu/sqrt(C2) #Har en for lav varians ved små h
mean(estSig) #1 meget præcist, både i - og + tilfældet
mean(estMu^2)
var(estT) #Præcist m. bandwidth 0.1 - for lavt m. bandwidth 0.01
setwd(Sys.getenv("masters-thesis"))
source("Kernels/kernels.R")
source("Estimation/estimates.R")
# Time parameters
mat <- 1
t <- 0:10000  # time_points
dt <- mat/t[length(t)]
# Define sigma
sig <- 0.01
sig2 <- sig^2
omega <- 0.5
omega2 <- omega^2
ksq <- 0.5 # K2
hd <- 0.01 #bandwidth in mu
hv <- 0.01 #bandwidth in sigma
N <- 1000
mu <- numeric(N)
sigmaEst <- numeric(N)
simAR<-function(n, rho, sd){
X<-rep(NA,n)
X[1]<-rnorm(1, 0, sd/sqrt(1-rho^2))
eps<-rnorm(n-1,0,sd)
for(i in 2:n){
X[i] <- rho*X[i-1]+eps[i-1]
}
return(X)
}
rho<- 0
for(i in 1:N) #Takes approx 30sec (i.e. slow)
{
#simulate brownian motion with noise
x <- rnorm(n = length(t) , mean = 0, sd = sqrt(sig2*dt))
x <- cumsum(x)
eps <- simAR(length(t), rho, sqrt(omega2))
#eps <- rnorm(n = length(t), mean = 0, sd = sqrt(omega2))
y <- x + eps
#put in data.frame for use in est.mu function
dataY<-data.frame(time = t*dt, Y = y)
#Get sigma estimates (vigtigt at bandwidth er rigtig lille)
mu[i] <- est.mu(dataY, hd, kern.leftexp, t.index = (length(t)-1))$mu[1] #Take out a random timeindex (9000)
sigmaEst[i] <- est.sigma(data = dataY, hv = hv, kern = kern.leftexp, wkern = kern.parzen,t.index = (length(t)-1),lag=15)$sig
}
C2 <- ksq/2*(2*omega2/(1-rho^2))*(1-rho)/(1+rho)
estT<-sqrt(hd)*sqrt(hv)*(mu/sqrt(sigmaEst)) #Giver Varians på én, rimelig præcist
estSig <- dt/hv*sigmaEst/C2
estMu <- sqrt(dt*hd)*mu/sqrt(C2) #Har en for lav varians ved små h
mean(estSig) #1 meget præcist, både i - og + tilfældet
mean(estMu^2)
var(estT) #Præcist m. bandwidth 0.1 - for lavt m. bandwidth 0.01
rho<- 0
for(i in 1:N) #Takes approx 30sec (i.e. slow)
{
#simulate brownian motion with noise
x <- rnorm(n = length(t) , mean = 0, sd = sqrt(sig2*dt))
x <- cumsum(x)
eps <- simAR(length(t), rho, sqrt(omega2))
#eps <- rnorm(n = length(t), mean = 0, sd = sqrt(omega2))
y <- x + eps
#put in data.frame for use in est.mu function
dataY<-data.frame(time = t*dt, Y = y)
#Get sigma estimates (vigtigt at bandwidth er rigtig lille)
mu[i] <- est.mu(dataY, hd, kern.leftexp, t.index = length(t))$mu[1] #Take out a random timeindex (9000)
sigmaEst[i] <- est.sigma(data = dataY, hv = hv, kern = kern.leftexp, wkern = kern.parzen,t.index = length(t),lag=15)$sig
}
C2 <- ksq/2*(2*omega2/(1-rho^2))*(1-rho)/(1+rho)
estT<-sqrt(hd)*sqrt(hv)*(mu/sqrt(sigmaEst)) #Giver Varians på én, rimelig præcist
estSig <- dt/hv*sigmaEst/C2
estMu <- sqrt(dt*hd)*mu/sqrt(C2) #Har en for lav varians ved små h
mean(estSig) #1 meget præcist, både i - og + tilfældet
mean(estMu^2)
var(estT) #Præcist m. bandwidth 0.1 - for l
N <- 1000
mu <- numeric(N)
sigmaEst <- numeric(N)
simAR<-function(n, rho, sd){
X<-rep(NA,n)
X[1]<-rnorm(1, 0, sd/sqrt(1-rho^2))
eps<-rnorm(n-1,0,sd)
for(i in 2:n){
X[i] <- rho*X[i-1]+eps[i-1]
}
return(X)
}
rho<- 0
for(i in 1:N) #Takes approx 30sec (i.e. slow)
{
#simulate brownian motion with noise
x <- rnorm(n = length(t) , mean = 0, sd = sqrt(sig2*dt))
x <- cumsum(x)
eps <- simAR(length(t), rho, sqrt(omega2))
#eps <- rnorm(n = length(t), mean = 0, sd = sqrt(omega2))
y <- x + eps
#put in data.frame for use in est.mu function
dataY<-data.frame(time = t*dt, Y = y)
#Get sigma estimates (vigtigt at bandwidth er rigtig lille)
mu[i] <- est.mu(dataY, hd, kern.leftexp, t.index = length(t))$mu[1] #Take out a random timeindex (9000)
sigmaEst[i] <- est.sigma(data = dataY, hv = hv, kern = kern.leftexp, wkern = kern.parzen,t.index = length(t),lag=15)$sig
}
C2 <- ksq/2*(2*omega2/(1-rho^2))*(1-rho)/(1+rho)
estT<-sqrt(hd)*sqrt(hv)*(mu/sqrt(sigmaEst)) #Giver Varians på én, rimelig præcist
estSig <- dt/hv*sigmaEst/C2
estMu <- sqrt(dt*hd)*mu/sqrt(C2) #Har en for lav varians ved små h
mean(estSig) #1 meget præcist, både i - og + tilfældet
mean(estMu^2)
var(estT) #Præcist m. bandwidth 0.1 - for lavt m. bandwidth 0.01
data <- dataY
hd <- hd
kern <- kern.leftexp
t.index <- length(t)
t.points <- NA
if(is.list(kern)) kern<-kern$kern
# mode-handling
mode = NA
if(is.na(t.index) & is.na(t.points)){
mode = 1
t<-data$time[1:(length(data$time))] # if nothing specified - every point in data
ind = 1:(length(data$time))
} else if(is.na(t.index) & !is.na(t.points)){
mode = 2
t<-t.points
ind = numeric(length(t))
#ind[1] = sum(data$time < t[1])
#ind[i] = data$time[ind[i-1]+sum(data$time[ind[i-1]:n] < t[i] )] #for 2 to n this may be faster than which.max
for(i in 2:length(t)){
ind[i] = which.max(data$time[data$time<t[i]])
}
}else{
mode = 3
t<-data$time[t.index]
ind = t.index
}
diffY<-diff(data$Y) #length er én mindre end Y
everySecondSeq<-seq(1L, length(diffY), by=2L) #Et ulige tal. Tager første dy osv.
dy<-c(0,diffY[everySecondSeq]) #Tager ikke den sidste
tempTime <- data$time[seq(1L, length(data$time), by = 2L)] #temporary placeholder, for compatibility
data <- NULL #remove data. Handles errors with e.g. data.frames
test <- seq(1L, length(data$time), by = 2L)
everySecondSeq<-seq(1L, length(diffY), by=2L) #Et ulige tal. Tager første dy osv.
data <- dataY
test <- seq(1L, length(data$time), by = 2L)
tt = length(t)
n = length(data$time)
mu = numeric(tt)          # We can only have bandwidth to end amount of calcs
diffY<-diff(data$Y) #length er én mindre end Y
everySecondSeq<-seq(1L, length(diffY), by=2L) #Et ulige tal. Tager første dy osv.
dy<-c(0,diffY[everySecondSeq]) #Tager ikke den sidste
tempTime <- data$time[seq(1L, length(data$time), by = 2L)] #temporary placeholder, for compatibility
data <- NULL #remove data. Handles errors with e.g. data.frames
data$time <- tempTime #creates list compatable with below
tt = length(t)
n = length(data$time)
mu = numeric(tt)          # We can only have bandwidth to end amount of calcs
t[1]
data <- dataY
hd <- hd
kern <- kern.leftexp
t.index <- length(t)
t.index <- 10000
t.points <- NA
if(is.list(kern)) kern<-kern$kern
# mode-handling
mode = NA
if(is.na(t.index) & is.na(t.points)){
mode = 1
t<-data$time[1:(length(data$time))] # if nothing specified - every point in data
ind = 1:(length(data$time))
} else if(is.na(t.index) & !is.na(t.points)){
mode = 2
t<-t.points
ind = numeric(length(t))
#ind[1] = sum(data$time < t[1])
#ind[i] = data$time[ind[i-1]+sum(data$time[ind[i-1]:n] < t[i] )] #for 2 to n this may be faster than which.max
for(i in 2:length(t)){
ind[i] = which.max(data$time[data$time<t[i]])
}
}else{
mode = 3
t<-data$time[t.index]
ind = t.index
}
diffY<-diff(data$Y) #length er én mindre end Y
everySecondSeq<-seq(1L, length(diffY), by=2L) #Et ulige tal. Tager første dy osv.
dy<-c(0,diffY[everySecondSeq]) #Tager ikke den sidste
tempTime <- data$time[seq(1L, length(data$time), by = 2L)] #temporary placeholder, for compatibility
data <- NULL #remove data. Handles errors with e.g. data.frames
data$time <- tempTime #creates list compatable with below
tt = length(t)
n = length(data$time)
mu = numeric(tt)          # We can only have bandwidth to end amount of calcs
t[1]
data$time[n]
data$time[n-1]
C2 <- ksq/2*(2*omega2/(1-rho^2))*(1-rho)/(1+rho)
estT<-sqrt(hd)*sqrt(hv)*(mu/sqrt(sigmaEst)) #Giver Varians på én, rimelig præcist
estSig <- dt/hv*sigmaEst/C2
estMu <- sqrt(dt*hd)*mu/sqrt(C2) #Har en for lav varians ved små h
mean(estSig) #1 meget præcist, både i - og + tilfældet
mean(estMu^2)
var(estT) #Præcist
setwd(Sys.getenv("masters-thesis"))
source("Kernels/kernels.R")
source("Estimation/estimates.R")
# Time parameters
mat <- 1
t <- 0:10000  # time_points
dt <- mat/t[length(t)]
# Define sigma
sig <- 0.01
sig2 <- sig^2
omega <- 0.5
omega2 <- omega^2
ksq <- 0.5 # K2
hd <- 0.01 #bandwidth in mu
hv <- 0.01 #bandwidth in sigma
N <- 1000
mu <- numeric(N)
sigmaEst <- numeric(N)
simAR<-function(n, rho, sd){
X<-rep(NA,n)
X[1]<-rnorm(1, 0, sd/sqrt(1-rho^2))
eps<-rnorm(n-1,0,sd)
for(i in 2:n){
X[i] <- rho*X[i-1]+eps[i-1]
}
return(X)
}
rho<- 0
for(i in 1:N) #Takes approx 30sec (i.e. slow)
{
#simulate brownian motion with noise
x <- rnorm(n = length(t) , mean = 0, sd = sqrt(sig2*dt))
x <- cumsum(x)
eps <- simAR(length(t), rho, sqrt(omega2))
#eps <- rnorm(n = length(t), mean = 0, sd = sqrt(omega2))
y <- x + eps
#put in data.frame for use in est.mu function
dataY<-data.frame(time = t*dt, Y = y)
#Get sigma estimates (vigtigt at bandwidth er rigtig lille)
mu[i] <- est.mu(dataY, hd, kern.leftexp, t.index = length(t))$mu[1] #Take out a random timeindex (9000)
sigmaEst[i] <- est.sigma(data = dataY, hv = hv, kern = kern.leftexp, wkern = kern.parzen,t.index = 10000,lag=15)$sig
}
C2 <- ksq/2*(2*omega2/(1-rho^2))*(1-rho)/(1+rho)
estT<-sqrt(hd)*sqrt(hv)*(mu/sqrt(sigmaEst)) #Giver Varians på én, rimelig præcist
estSig <- dt/hv*sigmaEst/C2
estMu <- sqrt(dt*hd)*mu/sqrt(C2) #Har en for lav varians ved små h
mean(estSig) #1 meget præcist, både i - og + tilfældet
mean(estMu^2)
var(estT) #Præcist m. bandwidth 0.1 - for lavt m. bandwidth 0.01
# Time parameters
mat <- 1
t <- 0:10000  # time_points
dt <- mat/t[length(t)]
# Define sigma
sig <- 0.01
sig2 <- sig^2
omega <- 0.5
omega2 <- omega^2
ksq <- 0.5 # K2
hd <- 0.1 #bandwidth in mu
hv <- 0.1 #bandwidth in sigma
N <- 1000
mu <- numeric(N)
sigmaEst <- numeric(N)
simAR<-function(n, rho, sd){
X<-rep(NA,n)
X[1]<-rnorm(1, 0, sd/sqrt(1-rho^2))
eps<-rnorm(n-1,0,sd)
for(i in 2:n){
X[i] <- rho*X[i-1]+eps[i-1]
}
return(X)
}
rho<- 0
for(i in 1:N) #Takes approx 30sec (i.e. slow)
{
#simulate brownian motion with noise
x <- rnorm(n = length(t) , mean = 0, sd = sqrt(sig2*dt))
x <- cumsum(x)
eps <- simAR(length(t), rho, sqrt(omega2))
#eps <- rnorm(n = length(t), mean = 0, sd = sqrt(omega2))
y <- x + eps
#put in data.frame for use in est.mu function
dataY<-data.frame(time = t*dt, Y = y)
#Get sigma estimates (vigtigt at bandwidth er rigtig lille)
mu[i] <- est.mu(dataY, hd, kern.leftexp, t.index = length(t))$mu[1] #Take out a random timeindex (9000)
sigmaEst[i] <- est.sigma(data = dataY, hv = hv, kern = kern.leftexp, wkern = kern.parzen,t.index = 10000,lag=15)$sig
}
C2 <- ksq/2*(2*omega2/(1-rho^2))*(1-rho)/(1+rho)
estT<-sqrt(hd)*sqrt(hv)*(mu/sqrt(sigmaEst)) #Giver Varians på én, rimelig præcist
estSig <- dt/hv*sigmaEst/C2
estMu <- sqrt(dt*hd)*mu/sqrt(C2) #Har en for lav varians ved små h
mean(estSig) #1 meget præcist, både i - og + tilfældet
mean(estMu^2)
var(estT) #Præcist m. bandwidth 0.1 - for lavt m. bandwidth 0.01
setwd(Sys.getenv("masters-thesis"))
source("Kernels/kernels.R")
source("Estimation/estimates.R")
# Time parameters
mat <- 1
t <- 0:10000  # time_points
dt <- mat/t[length(t)]
# Define sigma
sig <- 0.01
sig2 <- sig^2
omega <- 0.5
omega2 <- omega^2
ksq <- 0.5 # K2
hd <- 0.01 #bandwidth in mu
hv <- 0.01 #bandwidth in sigma
N <- 1000
mu <- numeric(N)
sigmaEst <- numeric(N)
simAR<-function(n, rho, sd){
X<-rep(NA,n)
X[1]<-rnorm(1, 0, sd/sqrt(1-rho^2))
eps<-rnorm(n-1,0,sd)
for(i in 2:n){
X[i] <- rho*X[i-1]+eps[i-1]
}
return(X)
}
rho<- 0
for(i in 1:N) #Takes approx 30sec (i.e. slow)
{
#simulate brownian motion with noise
x <- rnorm(n = length(t) , mean = 0, sd = sqrt(sig2*dt))
x <- cumsum(x)
eps <- simAR(length(t), rho, sqrt(omega2))
#eps <- rnorm(n = length(t), mean = 0, sd = sqrt(omega2))
y <- x + eps
#put in data.frame for use in est.mu function
dataY<-data.frame(time = t*dt, Y = y)
#Get sigma estimates (vigtigt at bandwidth er rigtig lille)
mu[i] <- est.mu(dataY, hd, kern.leftexp, t.index = length(t))$mu[1] #Take out a random timeindex (9000)
sigmaEst[i] <- est.sigma(data = dataY, hv = hv, kern = kern.leftexp, wkern = kern.parzen,t.index = 10000,lag=15)$sig
}
C2 <- ksq/2*(2*omega2/(1-rho^2))*(1-rho)/(1+rho)
estT<-sqrt(hd)*sqrt(hv)*(mu/sqrt(sigmaEst)) #Giver Varians på én, rimelig præcist
estSig <- dt/hv*sigmaEst/C2
estMu <- sqrt(dt*hd)*mu/sqrt(C2) #Har en for lav varians ved små h
mean(estSig) #1 meget præcist, både i - og + tilfældet
mean(estMu^2)
var(estT) #Præcist m. bandwidth 0.1 - alt for lavt m. bandwidth 0.01
setwd(Sys.getenv("masters-thesis"))
source("Kernels/kernels.R")
source("Estimation/estimates.R")
# Time parameters
mat <- 1
t <- 0:10000  # time_points
dt <- mat/t[length(t)]
# Define sigma
sig <- 0.01
sig2 <- sig^2
omega <- 0.5
omega2 <- omega^2
ksq <- 0.5 # K2
hd <- 0.01 #bandwidth in mu
hv <- 0.01 #bandwidth in sigma
N <- 1000
mu <- numeric(N)
sigmaEst <- numeric(N)
simAR<-function(n, rho, sd){
X<-rep(NA,n)
X[1]<-rnorm(1, 0, sd/sqrt(1-rho^2))
eps<-rnorm(n-1,0,sd)
for(i in 2:n){
X[i] <- rho*X[i-1]+eps[i-1]
}
return(X)
}
rho<- 0
for(i in 1:N) #Takes approx 30sec (i.e. slow)
{
#simulate brownian motion with noise
x <- rnorm(n = length(t) , mean = 0, sd = sqrt(sig2*dt))
x <- cumsum(x)
eps <- simAR(length(t), rho, sqrt(omega2))
#eps <- rnorm(n = length(t), mean = 0, sd = sqrt(omega2))
y <- x + eps
#put in data.frame for use in est.mu function
dataY<-data.frame(time = t*dt, Y = y)
#Get sigma estimates (vigtigt at bandwidth er rigtig lille)
mu[i] <- est.mu(dataY, hd, kern.leftexp, t.index = length(t))$mu[1] #Take out a random timeindex (9000)
sigmaEst[i] <- est.sigma(data = dataY, hv = hv, kern = kern.leftexp, wkern = kern.parzen,t.index = 10000,lag=15)$sig
}
C2 <- ksq/2*(2*omega2/(1-rho^2))*(1-rho)/(1+rho)
estT<-sqrt(hd)*sqrt(hv)*(mu/sqrt(sigmaEst)) #Giver Varians på én, rimelig præcist
estSig <- dt/hv*sigmaEst/C2
estMu <- sqrt(dt*hd)*mu/sqrt(C2) #Har en for lav varians ved små h
mean(estSig) #1 meget præcist, både i - og + tilfældet
mean(estMu^2)
var(estT) #Præcist m. bandwidth 0.1 - alt for lavt m. bandwidt
rho<- 0.5
for(i in 1:N) #Takes approx 30sec (i.e. slow)
{
#simulate brownian motion with noise
x <- rnorm(n = length(t) , mean = 0, sd = sqrt(sig2*dt))
x <- cumsum(x)
eps <- simAR(length(t), rho, sqrt(omega2))
#eps <- rnorm(n = length(t), mean = 0, sd = sqrt(omega2))
y <- x + eps
#put in data.frame for use in est.mu function
dataY<-data.frame(time = t*dt, Y = y)
#Get sigma estimates (vigtigt at bandwidth er rigtig lille)
mu[i] <- est.mu(dataY, hd, kern.leftexp, t.index = length(t))$mu[1] #Take out a random timeindex (9000)
sigmaEst[i] <- est.sigma(data = dataY, hv = hv, kern = kern.leftexp, wkern = kern.parzen,t.index = 10000,lag=15)$sig
}
C2 <- ksq/2*(2*omega2/(1-rho^2))*(1-rho)/(1+rho)
estT<-sqrt(hd)*sqrt(hv)*(mu/sqrt(sigmaEst)) #Giver Varians på én, rimelig præcist
estSig <- dt/hv*sigmaEst/C2
estMu <- sqrt(dt*hd)*mu/sqrt(C2) #Har en for lav varians ved små h
mean(estSig) #1 meget præcist, både i - og + tilfældet
mean(estMu^2)
var(estT) #Præcist
mat <- 1
t <- 0:100000  # time_points
dt <- mat/t[length(t)]
# Define sigma
sig <- 0.01
sig2 <- sig^2
omega <- 0.5
omega2 <- omega^2
ksq <- 0.5 # K2
hd <- 0.01 #bandwidth in mu
hv <- 0.01 #bandwidth in sigma
N <- 200
mu <- numeric(N)
sigmaEst <- numeric(N)
simAR<-function(n, rho, sd){
X<-rep(NA,n)
X[1]<-rnorm(1, 0, sd/sqrt(1-rho^2))
eps<-rnorm(n-1,0,sd)
for(i in 2:n){
X[i] <- rho*X[i-1]+eps[i-1]
}
return(X)
}
rho<- 0.5
for(i in 1:N) #Takes approx 30sec (i.e. slow)
{
#simulate brownian motion with noise
x <- rnorm(n = length(t) , mean = 0, sd = sqrt(sig2*dt))
x <- cumsum(x)
eps <- simAR(length(t), rho, sqrt(omega2))
#eps <- rnorm(n = length(t), mean = 0, sd = sqrt(omega2))
y <- x + eps
#put in data.frame for use in est.mu function
dataY<-data.frame(time = t*dt, Y = y)
#Get sigma estimates (vigtigt at bandwidth er rigtig lille)
mu[i] <- est.mu(dataY, hd, kern.leftexp, t.index = length(t))$mu[1] #Take out a random timeindex (9000)
sigmaEst[i] <- est.sigma(data = dataY, hv = hv, kern = kern.leftexp, wkern = kern.parzen,t.index = 10000,lag=15)$sig
}
C2 <- ksq/2*(2*omega2/(1-rho^2))*(1-rho)/(1+rho)
estT<-sqrt(hd)*sqrt(hv)*(mu/sqrt(sigmaEst)) #Giver Varians på én, rimelig præcist
estSig <- dt/hv*sigmaEst/C2
estMu <- sqrt(dt*hd)*mu/sqrt(C2) #Har en for lav varians ved små h
mean(estSig) #1 meget præcist, både i - og + tilfældet
mean(estMu^2)
var(estT) #Alt for lavt m. bandwidth 0.01 og
N <- 200
mu <- numeric(N)
sigmaEst <- numeric(N)
simAR<-function(n, rho, sd){
X<-rep(NA,n)
X[1]<-rnorm(1, 0, sd/sqrt(1-rho^2))
eps<-rnorm(n-1,0,sd)
for(i in 2:n){
X[i] <- rho*X[i-1]+eps[i-1]
}
return(X)
}
rho<- 0.5
for(i in 1:N) #Takes approx 30sec (i.e. slow)
{
#simulate brownian motion with noise
x <- rnorm(n = length(t) , mean = 0, sd = sqrt(sig2*dt))
x <- cumsum(x)
eps <- simAR(length(t), rho, sqrt(omega2))
#eps <- rnorm(n = length(t), mean = 0, sd = sqrt(omega2))
y <- x + eps
#put in data.frame for use in est.mu function
dataY<-data.frame(time = t*dt, Y = y)
#Get sigma estimates (vigtigt at bandwidth er rigtig lille)
mu[i] <- est.mu(dataY, hd, kern.leftexp, t.index = length(t))$mu[1] #Take out a random timeindex (9000)
sigmaEst[i] <- est.sigma(data = dataY, hv = hv, kern = kern.leftexp, wkern = kern.parzen,t.index = 10000,lag=15)$sig
}
C2 <- ksq/2*(2*omega2/(1-rho^2))*(1-rho)/(1+rho)
estT<-sqrt(hd)*sqrt(hv)*(mu/sqrt(sigmaEst)) #Giver Varians på én, rimelig præcist
estSig <- dt/hv*sigmaEst/C2
estMu <- sqrt(dt*hd)*mu/sqrt(C2) #Har en for lav varians ved små h
mean(estSig) #1 meget præcist, både i - og + tilfældet
mean(estMu^2)
var(estT) #Alt for lavt m. bandwidth 0.01 og rho = 0.5
