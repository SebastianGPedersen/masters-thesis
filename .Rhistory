}
# return list
return(list(time = t, sig = sig))
}
test<-(est.sigma(data = sim, hv = 0.001, kern = kern.leftexp, wkern = kern.parzen)$sig
-est.sigma2(data = sim, hv = 0.001, kern = kern.leftexp, wkern = kern.parzen)$sig)
test
est.sigma2 <- function(data, hv, kern, wkern, t.index=NA, lag="auto"){   # we could do lag = "auto"
# data list should include a times column and the Y column (log returns)
# Handle lag
if(lag=="auto") lag = 15 #temp
# kern handling
if(is.list(kern)) kern<-kern$kern
if(!is.function(kern)) stop("kern should be either function or list containing function")
if(is.list(wkern)) wkern<-wkern$kern
if(!is.function(wkern)) stop("wkern should be either function or list containing function")
n = length(data$time)
# if missing handling:
if(is.na(t.index)){
start = lag+1
t<-data$time[start:n] # if nothing specified - every point in data
ind<-start:n
}else{
t<-data$time[t.index]
ind<-t.index
}
# t should now be data$time points
tt = length(t)
sig = numeric(tt)
#dy = cbind(0,t(diff(t(data$Y))))               # diff only does each column seperately / so we transpose to get row wise
dy = diff(data$Y)
gamma2<-function(l, t){
# to be used in the loop with j as n
# if j+l+1 < n then we should not hit out of range
#if(j+l < n){
if(1 > 2){
out<- sum(   kern( (data$time[(l+1):(j+l)] - t)/hv )*
dy[(l+1):(j+l)]*
kern( (data$time[1:j] - t)/hv )*   # TEGN Hvordan Autocov vinduet ser ud
dy[1:j]   )
if(is.na(out)) stop("out is NA")
}
else{
out<- sum(   kern( (data$time[(l+1):(n-1)] - t)/hv )*
dy[(l+1):(n-1)]*       #indices are literally #1 reason for bugs
kern( (data$time[1:(n-l-1)] - t)/hv )*
dy[1:(n-l-1)]   )
}
return(out)
}
gamma<-function(l, t){
# the standard where end = n
l <- abs(l)
out<- sum(   kern( (data$time[(l+1):(n-1)] - t)/hv )*
dy[(l+1):(n-1)]*       #indices are literally #1 reason for bugs
kern( (data$time[1:(n-l-1)] - t)/hv )*
dy[1:(n-l-1)]   )
return(out)
}
for (j in 1:(tt-1)) {
sig[j] = sum(  (kern(   (data$time[1:j] - t[j])/hv   )*dy[1:j])^2  )  # l = 0
if (lag >=1) {
for(l in 1:lag){
sig[j] = sig[j] + 2*(wkern(l/(lag+1))*gamma(l,t[j]))
}
}
}
sig[tt] = sum(  (kern(   (data$time[1:(n-1)] - t[tt])/hv   )*dy[1:(n-1)])^2  )  # l = 0
if (lag >=1) {
for(l in 1:lag){
sig[tt] = sig[tt] + 2*(wkern(l/(lag+1))*gamma(l, t[tt]))
}
}
# return list
return(list(time = t, sig = sig))
}
test<-(est.sigma(data = sim, hv = 0.001, kern = kern.leftexp, wkern = kern.parzen)$sig
-est.sigma2(data = sim, hv = 0.001, kern = kern.leftexp, wkern = kern.parzen)$sig)
test
est.sigma2 <- function(data, hv, kern, wkern, t.index=NA, lag="auto"){   # we could do lag = "auto"
# data list should include a times column and the Y column (log returns)
# Handle lag
if(lag=="auto") lag = 15 #temp
# kern handling
if(is.list(kern)) kern<-kern$kern
if(!is.function(kern)) stop("kern should be either function or list containing function")
if(is.list(wkern)) wkern<-wkern$kern
if(!is.function(wkern)) stop("wkern should be either function or list containing function")
n = length(data$time)
# if missing handling:
if(is.na(t.index)){
start = lag+1
t<-data$time[start:n] # if nothing specified - every point in data
ind<-start:n
}else{
t<-data$time[t.index]
ind<-t.index
}
# t should now be data$time points
tt = length(t)
sig = numeric(tt)
#dy = cbind(0,t(diff(t(data$Y))))               # diff only does each column seperately / so we transpose to get row wise
dy = diff(data$Y)
gamma2<-function(l, t){
# to be used in the loop with j as n
# if j+l+1 < n then we should not hit out of range
#if(j+l < n){
if(1 > 2){
out<- sum(   kern( (data$time[(l+1):(ind[j]+l)] - t)/hv )*
dy[(l+1):(ind[j]+l)]*
kern( (data$time[1:ind[j]] - t)/hv )*   # TEGN Hvordan Autocov vinduet ser ud
dy[1:ind[j]]   )
if(is.na(out)) stop("out is NA")
}
else{
out<- sum(   kern( (data$time[(l+1):(n-1)] - t)/hv )*
dy[(l+1):(n-1)]*       #indices are literally #1 reason for bugs
kern( (data$time[1:(n-l-1)] - t)/hv )*
dy[1:(n-l-1)]   )
}
return(out)
}
gamma<-function(l, t){
# the standard where end = n
l <- abs(l)
out<- sum(   kern( (data$time[(l+1):(n-1)] - t)/hv )*
dy[(l+1):(n-1)]*       #indices are literally #1 reason for bugs
kern( (data$time[1:(n-l-1)] - t)/hv )*
dy[1:(n-l-1)]   )
return(out)
}
for (j in 1:(tt-1)) {
sig[j] = sum(  (kern(   (data$time[1:ind[j]] - t[j])/hv   )*dy[1:ind[j]])^2  )  # l = 0
if (lag >=1) {
for(l in 1:lag){
sig[j] = sig[j] + 2*(wkern(l/(lag+1))*gamma(l,t[j])) #gamma2
}
}
}
sig[tt] = sum(  (kern(   (data$time[1:(n-1)] - t[tt])/hv   )*dy[1:(n-1)])^2  )  # l = 0
if (lag >=1) {
for(l in 1:lag){
sig[tt] = sig[tt] + 2*(wkern(l/(lag+1))*gamma(l, t[tt]))
}
}
# return list
return(list(time = t, sig = sig))
}
lags<-(est.sigma(lag=0, data = sim, hv = 0.001, kern = kern.leftexp, wkern = kern.parzen)$sig
-est.sigma2(lag=0, data = sim, hv = 0.001, kern = kern.leftexp, wkern = kern.parzen)$sig)
lags
(test<-(est.sigma(data = sim, hv = 0.001, kern = kern.leftexp, wkern = kern.parzen)$sig
-est.sigma2(data = sim, hv = 0.001, kern = kern.leftexp, wkern = kern.parzen)$sig))
est.sigma2 <- function(data, hv, kern, wkern, t.index=NA, lag="auto"){   # we could do lag = "auto"
# data list should include a times column and the Y column (log returns)
# Handle lag
if(lag=="auto") lag = 15 #temp
# kern handling
if(is.list(kern)) kern<-kern$kern
if(!is.function(kern)) stop("kern should be either function or list containing function")
if(is.list(wkern)) wkern<-wkern$kern
if(!is.function(wkern)) stop("wkern should be either function or list containing function")
n = length(data$time)
# if missing handling:
if(is.na(t.index)){
start = lag+1
t<-data$time[start:n] # if nothing specified - every point in data
ind<-start:n
}else{
t<-data$time[t.index]
ind<-t.index
}
# t should now be data$time points
tt = length(t)
sig = numeric(tt)
#dy = cbind(0,t(diff(t(data$Y))))               # diff only does each column seperately / so we transpose to get row wise
dy = diff(data$Y)
gamma2<-function(l, t){
# to be used in the loop with j as n
# if j+l+1 < n then we should not hit out of range
#if(j+l < n){
if(1 > 2){
out<- sum(   kern( (data$time[(l+1):(ind[j]+l)] - t)/hv )*
dy[(l+1):(ind[j]+l)]*
kern( (data$time[1:ind[j]] - t)/hv )*   # TEGN Hvordan Autocov vinduet ser ud
dy[1:ind[j]]   )
if(is.na(out)) stop("out is NA")
}
else{
out<- sum(   kern( (data$time[(l+1):(n-1)] - t)/hv )*
dy[(l+1):(n-1)]*       #indices are literally #1 reason for bugs
kern( (data$time[1:(n-l-1)] - t)/hv )*
dy[1:(n-l-1)]   )
}
return(out)
}
gamma<-function(l, t){
# the standard where end = n
l <- abs(l)
out<- sum(   kern( (data$time[(l+1):(n-1)] - t)/hv )*
dy[(l+1):(n-1)]*       #indices are literally #1 reason for bugs
kern( (data$time[1:(n-l-1)] - t)/hv )*
dy[1:(n-l-1)]   )
return(out)
}
for (j in 1:(tt-1)) {
sig[j] = sum(  (kern(   (data$time[1:ind[j]] - t[j])/hv   )*dy[1:ind[j]])^2  )  # l = 0
if (lag >=1) {
for(l in 1:lag){
sig[j] = sig[j] + 2*(wkern(l/(lag+1))*gamma2(l,t[j])) #gamma2
}
}
}
sig[tt] = sum(  (kern(   (data$time[1:(n-1)] - t[tt])/hv   )*dy[1:(n-1)])^2  )  # l = 0
if (lag >=1) {
for(l in 1:lag){
sig[tt] = sig[tt] + 2*(wkern(l/(lag+1))*gamma(l, t[tt]))
}
}
# return list
return(list(time = t, sig = sig))
}
(lags<-(est.sigma(lag=0, data = sim, hv = 0.001, kern = kern.leftexp, wkern = kern.parzen)$sig
-est.sigma2(lag=0, data = sim, hv = 0.001, kern = kern.leftexp, wkern = kern.parzen)$sig))
(test<-(est.sigma(data = sim, hv = 0.001, kern = kern.leftexp, wkern = kern.parzen)$sig
-est.sigma2(data = sim, hv = 0.001, kern = kern.leftexp, wkern = kern.parzen)$sig))
(netto<-(est.sigma(data = sim, hv = 0.001, kern = kern.leftexp, wkern = kern.parzen, t.index = tind)$sig
-est.sigma2(data = sim, hv = 0.001, kern = kern.leftexp, wkern = kern.parzen, t.index = tind)$sig))
netto
require(microbenchmark)
microbenchmark(est.sigma(data = sim, hv = 0.001, kern = kern.leftexp, wkern = kern.parzen, t.index = tind))
warnings
warnings()
microbenchmark(est.sigma(data = sim, hv = 0.001, kern = kern.leftexp, wkern = kern.parzen, t.index = tind))
tind
microbenchmark(est.sigma2(data = sim, hv = 0.001, kern = kern.leftexp, wkern = kern.parzen, t.index = tind))
install.packages("profvis")
profvis(est.sigma2(data = sim, hv = 0.001, kern = kern.leftexp, wkern = kern.parzen))
require(profvis)
profvis(est.sigma(data = sim, hv = 0.001, kern = kern.leftexp, wkern = kern.parzen))
est.sigma2 <- function(data, hv, kern, wkern, t.index=NA, lag="auto"){   # we could do lag = "auto"
# data list should include a times column and the Y column (log returns)
# Handle lag
if(lag=="auto") lag = 15 #temp
# kern handling
if(is.list(kern)) kern<-kern$kern
if(!is.function(kern)) stop("kern should be either function or list containing function")
if(is.list(wkern)) wkern<-wkern$kern
if(!is.function(wkern)) stop("wkern should be either function or list containing function")
n = length(data$time)
# if missing handling:
if(is.na(t.index)){
start = lag+1
t<-data$time[start:n] # if nothing specified - every point in data
ind<-start:n
}else{
t<-data$time[t.index]
ind<-t.index
}
# t should now be data$time points
tt = length(t)
sig = numeric(tt)
#dy = cbind(0,t(diff(t(data$Y))))               # diff only does each column seperately / so we transpose to get row wise
dy = diff(data$Y)
gamma2<-function(l, t){
# to be used in the loop with j as n
# if j+l+1 < n then we should not hit out of range
#if(j+l < n){
#if(1 > 2){
#  out<- sum(   kern( (data$time[(l+1):(ind[j]+l)] - t)/hv )*
#                 dy[(l+1):(ind[j]+l)]*
#                 kern( (data$time[1:ind[j]] - t)/hv )*   # TEGN Hvordan Autocov vinduet ser ud
#                 dy[1:ind[j]]   )
#  if(is.na(out)) stop("out is NA")
#
#}
#else{
#  out<- sum(   kern( (data$time[(l+1):(n-1)] - t)/hv )*
#                 dy[(l+1):(n-1)]*       #indices are literally #1 reason for bugs
#                 kern( (data$time[1:(n-l-1)] - t)/hv )*
#                 dy[1:(n-l-1)]   )
#}
out<-ifelse(j+l < n, sum(   kern( (data$time[(l+1):(ind[j]+l)] - t)/hv )*
dy[(l+1):(ind[j]+l)]*
kern( (data$time[1:ind[j]] - t)/hv )*   # TEGN Hvordan Autocov vinduet ser ud
dy[1:ind[j]]   ),
sum(   kern( (data$time[(l+1):(n-1)] - t)/hv )*
dy[(l+1):(n-1)]*       #indices are literally #1 reason for bugs
kern( (data$time[1:(n-l-1)] - t)/hv )*
dy[1:(n-l-1)]   ))
return(out)
}
gamma<-function(l, t){
# the standard where end = n
l <- abs(l)
out<- sum(   kern( (data$time[(l+1):(n-1)] - t)/hv )*
dy[(l+1):(n-1)]*       #indices are literally #1 reason for bugs
kern( (data$time[1:(n-l-1)] - t)/hv )*
dy[1:(n-l-1)]   )
return(out)
}
for (j in 1:(tt-1)) {
sig[j] = sum(  (kern(   (data$time[1:ind[j]] - t[j])/hv   )*dy[1:ind[j]])^2  )  # l = 0
if (lag >=1) {
for(l in 1:lag){
sig[j] = sig[j] + 2*(wkern(l/(lag+1))*gamma2(l,t[j])) #gamma2
}
}
}
sig[tt] = sum(  (kern(   (data$time[1:(n-1)] - t[tt])/hv   )*dy[1:(n-1)])^2  )  # l = 0
if (lag >=1) {
for(l in 1:lag){
sig[tt] = sig[tt] + 2*(wkern(l/(lag+1))*gamma(l, t[tt]))
}
}
# return list
return(list(time = t, sig = sig))
}
(lags<-(est.sigma(lag=0, data = sim, hv = 0.001, kern = kern.leftexp, wkern = kern.parzen)$sig
-est.sigma2(lag=0, data = sim, hv = 0.001, kern = kern.leftexp, wkern = kern.parzen)$sig))
(test<-(est.sigma(data = sim, hv = 0.001, kern = kern.leftexp, wkern = kern.parzen)$sig
-est.sigma2(data = sim, hv = 0.001, kern = kern.leftexp, wkern = kern.parzen)$sig))
warnings()
(test<-(est.sigma(data = sim, hv = 0.001, kern = kern.leftexp, wkern = kern.parzen)$sig
-est.sigma2(data = sim, hv = 0.001, kern = kern.leftexp, wkern = kern.parzen)$sig))
est.sigma2 <- function(data, hv, kern, wkern, t.index=NA, lag="auto"){   # we could do lag = "auto"
# data list should include a times column and the Y column (log returns)
# Handle lag
if(lag=="auto") lag = 15 #temp
# kern handling
if(is.list(kern)) kern<-kern$kern
if(!is.function(kern)) stop("kern should be either function or list containing function")
if(is.list(wkern)) wkern<-wkern$kern
if(!is.function(wkern)) stop("wkern should be either function or list containing function")
n = length(data$time)
# if missing handling:
if(is.na(t.index)){
start = lag+1
t<-data$time[start:n] # if nothing specified - every point in data
ind<-start:n
}else{
t<-data$time[t.index]
ind<-t.index
}
# t should now be data$time points
tt = length(t)
sig = numeric(tt)
#dy = cbind(0,t(diff(t(data$Y))))               # diff only does each column seperately / so we transpose to get row wise
dy = diff(data$Y)
gamma2<-function(l, t){
# to be used in the loop with j as n
# if j+l+1 < n then we should not hit out of range
#if(ind[j]+l < n){
#if(1 > 2){
#  out<- sum(   kern( (data$time[(l+1):(ind[j]+l)] - t)/hv )*
#                 dy[(l+1):(ind[j]+l)]*
#                 kern( (data$time[1:ind[j]] - t)/hv )*   # TEGN Hvordan Autocov vinduet ser ud
#                 dy[1:ind[j]]   )
#  if(is.na(out)) stop("out is NA")
#
#}
#else{
#  out<- sum(   kern( (data$time[(l+1):(n-1)] - t)/hv )*
#                 dy[(l+1):(n-1)]*       #indices are literally #1 reason for bugs
#                 kern( (data$time[1:(n-l-1)] - t)/hv )*
#                 dy[1:(n-l-1)]   )
#}
out<-ifelse(ind[j]+l < n, sum(   kern( (data$time[(l+1):(ind[j]+l)] - t)/hv )*
dy[(l+1):(ind[j]+l)]*
kern( (data$time[1:ind[j]] - t)/hv )*   # TEGN Hvordan Autocov vinduet ser ud
dy[1:ind[j]]   ),
sum(   kern( (data$time[(l+1):(n-1)] - t)/hv )*
dy[(l+1):(n-1)]*       #indices are literally #1 reason for bugs
kern( (data$time[1:(n-l-1)] - t)/hv )*
dy[1:(n-l-1)]   ))
return(out)
}
gamma<-function(l, t){
# the standard where end = n
l <- abs(l)
out<- sum(   kern( (data$time[(l+1):(n-1)] - t)/hv )*
dy[(l+1):(n-1)]*       #indices are literally #1 reason for bugs
kern( (data$time[1:(n-l-1)] - t)/hv )*
dy[1:(n-l-1)]   )
return(out)
}
for (j in 1:(tt-1)) {
sig[j] = sum(  (kern(   (data$time[1:ind[j]] - t[j])/hv   )*dy[1:ind[j]])^2  )  # l = 0
if (lag >=1) {
for(l in 1:lag){
sig[j] = sig[j] + 2*(wkern(l/(lag+1))*gamma2(l,t[j])) #gamma2
}
}
}
sig[tt] = sum(  (kern(   (data$time[1:(n-1)] - t[tt])/hv   )*dy[1:(n-1)])^2  )  # l = 0
if (lag >=1) {
for(l in 1:lag){
sig[tt] = sig[tt] + 2*(wkern(l/(lag+1))*gamma(l, t[tt]))
}
}
# return list
return(list(time = t, sig = sig))
}
(test<-(est.sigma(data = sim, hv = 0.001, kern = kern.leftexp, wkern = kern.parzen)$sig
-est.sigma2(data = sim, hv = 0.001, kern = kern.leftexp, wkern = kern.parzen)$sig))
(netto<-(est.sigma(data = sim, hv = 0.001, kern = kern.leftexp, wkern = kern.parzen, t.index = tind)$sig
-est.sigma2(data = sim, hv = 0.001, kern = kern.leftexp, wkern = kern.parzen, t.index = tind)$sig))
microbenchmark(est.sigma(data = sim, hv = 0.001, kern = kern.leftexp, wkern = kern.parzen, t.index = tind))
microbenchmark(est.sigma2(data = sim, hv = 0.001, kern = kern.leftexp, wkern = kern.parzen, t.index = tind))
setting <- sim.setup(Npath = 2, Nstep = 10000)
sims<-sim.heston(setting)
sim<-sim.path(1, sims)
tind<-seq(from=2, to=10000, by=10)
test<-est.mu(data = sim, hd = 0.001, kern = kern.leftexp, t.index = tind)$mu-est.mu2(data = sim, hd = 0.001, kern = kern.leftexp, t.index = tind)$mu
test
est.sigma2 <- function(data, hv, kern, wkern, t.index=NA, lag="auto"){   # we could do lag = "auto"
# data list should include a times column and the Y column (log returns)
# Handle lag
if(lag=="auto") lag = 15 #temp
# kern handling
if(is.list(kern)) kern<-kern$kern
if(!is.function(kern)) stop("kern should be either function or list containing function")
if(is.list(wkern)) wkern<-wkern$kern
if(!is.function(wkern)) stop("wkern should be either function or list containing function")
n = length(data$time)
# if missing handling:
if(is.na(t.index)){
start = lag+1
t<-data$time[start:n] # if nothing specified - every point in data
ind<-start:n
}else{
t<-data$time[t.index]
ind<-t.index
}
# t should now be data$time points
tt = length(t)
sig = numeric(tt)
#dy = cbind(0,t(diff(t(data$Y))))               # diff only does each column seperately / so we transpose to get row wise
dy = diff(data$Y)
gamma2<-function(l, t){
# to be used in the loop with j as n
{
# if j+l+1 < n then we should not hit out of range
#if(ind[j]+l < n){
#if(1 > 2){
#  out<- sum(   kern( (data$time[(l+1):(ind[j]+l)] - t)/hv )*
#                 dy[(l+1):(ind[j]+l)]*
#                 kern( (data$time[1:ind[j]] - t)/hv )*   # TEGN Hvordan Autocov vinduet ser ud
#                 dy[1:ind[j]]   )
#  if(is.na(out)) stop("out is NA")
#
#}
#else{
#  out<- sum(   kern( (data$time[(l+1):(n-1)] - t)/hv )*
#                 dy[(l+1):(n-1)]*       #indices are literally #1 reason for bugs
#                 kern( (data$time[1:(n-l-1)] - t)/hv )*
#                 dy[1:(n-l-1)]   )
#}
}
out<-ifelse(ind[j]+l < n, sum(   kern( (data$time[(l+1):(ind[j]+l)] - t)/hv )*
dy[(l+1):(ind[j]+l)]*
kern( (data$time[1:ind[j]] - t)/hv )*   # TEGN Hvordan Autocov vinduet ser ud
dy[1:ind[j]]   ),
sum(   kern( (data$time[(l+1):(n-1)] - t)/hv )*
dy[(l+1):(n-1)]*       #indices are literally #1 reason for bugs
kern( (data$time[1:(n-l-1)] - t)/hv )*
dy[1:(n-l-1)]   ))
return(out)
}
gamma<-function(l, t){
# the standard where end = n
l <- abs(l)
out<- sum(   kern( (data$time[(l+1):(n-1)] - t)/hv )*
dy[(l+1):(n-1)]*       #indices are literally #1 reason for bugs
kern( (data$time[1:(n-l-1)] - t)/hv )*
dy[1:(n-l-1)]   )
return(out)
}
for (j in 1:(tt-1)) {
sig[j] = sum(  (kern(   (data$time[1:ind[j]] - t[j])/hv   )*dy[1:ind[j]])^2  )  # l = 0
if (lag >=1) {
for(l in 1:lag){
sig[j] = sig[j] + 2*(wkern(l/(lag+1))*gamma2(l,t[j])) #gamma2
}
}
}
sig[tt] = sum(  (kern(   (data$time[1:(n-1)] - t[tt])/hv   )*dy[1:(n-1)])^2  )  # l = 0
if (lag >=1) {
for(l in 1:lag){
sig[tt] = sig[tt] + 2*(wkern(l/(lag+1))*gamma(l, t[tt]))
}
}
# return list
return(list(time = t, sig = sig))
}
(test<-est.mu(data = sim, hd = 0.001, kern = kern.leftexp, t.index = tind)$mu-est.mu2(data = sim, hd = 0.001, kern = kern.leftexp, t.index = tind)$mu)
(lags<-(est.sigma(lag=0, data = sim, hv = 0.001, kern = kern.leftexp, wkern = kern.parzen)$sig
-est.sigma2(lag=0, data = sim, hv = 0.001, kern = kern.leftexp, wkern = kern.parzen)$sig))
(netto<-(est.sigma(data = sim, hv = 0.001, kern = kern.leftexp, wkern = kern.parzen, t.index = tind)$sig
-est.sigma2(data = sim, hv = 0.001, kern = kern.leftexp, wkern = kern.parzen, t.index = tind)$sig))
microbenchmark(est.sigma(data = sim, hv = 0.001, kern = kern.leftexp, wkern = kern.parzen, t.index = tind), eval = 10)
microbenchmark(est.sigma(data = sim, hv = 0.001, kern = kern.leftexp, wkern = kern.parzen, t.index = tind),
est.sigma2(data = sim, hv = 0.001, kern = kern.leftexp, wkern = kern.parzen, t.index = tind), eval = 10)
tind<-seq(from=2, to=10000, by=100)
microbenchmark(est.sigma(data = sim, hv = 0.001, kern = kern.leftexp, wkern = kern.parzen, t.index = tind),
est.sigma2(data = sim, hv = 0.001, kern = kern.leftexp, wkern = kern.parzen, t.index = tind), eval = 1)
2488572440.6 / 1000000000
microbenchmark(est.sigma(data = sim, hv = 0.001, kern = kern.leftexp, wkern = kern.parzen, t.index = tind),
est.sigma2(data = sim, hv = 0.001, kern = kern.leftexp, wkern = kern.parzen, t.index = tind), times = 1)
microbenchmark(est.sigma(data = sim, hv = 0.001, kern = kern.leftexp, wkern = kern.parzen, t.index = tind),
est.sigma2(data = sim, hv = 0.001, kern = kern.leftexp, wkern = kern.parzen, t.index = tind), times = 10)
warnings()
