exp(1:5)
sim.setup <- function(kappa=5, theta=0.0225, xi = 0.4, rho = -0.5, gamma = 0.5,
mat = 6.5/(24*52), Nsteps = 1000, Npath = 10000){
list(kappa = kappa, theta = theta, xi = xi, rho = rho, gamma = gamma, mat = mat, Nsteps = Nsteps, Npath = Npath)
}
sim.heston<-function(settings){
N = settings$Npath
mat = settings$mat
steps = settings$Nsteps
kappa = settings$kappa
theta = settings$theta
xi = settings$xi       ##vol of vol
rho = settings$rho
gamma = settings$gamma
dt = mat/steps #dt is in years
time = 0:steps*dt
X = matrix(nrow = N, ncol = steps+1)
Y = matrix(nrow = N, ncol = steps+1)
vol = matrix(nrow = N, ncol = steps+1) #matrix if we want to save values along the way
call = numeric(N) # testing purpose
X[, 1] = 0
vol[, 1] = rgamma(N, 2*kappa*theta/xi^2, 2*kappa/xi^2)
Y[, 1] = X[,1] + gamma*sqrt(vol[,1])/sqrt(steps)*rnorm(N,0,1) #Changed from vol to sqrt(vol) /Seb 20.02.18
for(i in 2:(steps+1)){
NS = rnorm(N,0,1)
NV = rho*NS + sqrt(1-rho^2)*rnorm(N,0,1) #From StatÃ (Olivier) Theorem I.5 or Graphical example 1.20
#X[,i] =   X[,i-1] + X[,i-1]*sqrt(vol[,i-1])*sqrt(dt)*NS         #non-ln x's
X[,i] =   X[,i-1] + sqrt(vol[,i-1])*sqrt(dt)*NS
x = vol[,i-1] + kappa*(theta - vol[,i-1])*dt
y = sqrt(  log(  (xi^2*vol[,i-1]*dt)/(x^2) + 1  )  )
vol[, i] = x*exp(-0.5*y^2+y*NV  )
#Observed Y
omega = gamma*sqrt(vol[,i])/sqrt(steps)     # n corresponds to steps and not repetitions N? #should vol be i-1? No?
Y[,i] = X[,i] + omega * rnorm(N,0,1)
pay<-100*exp(X[,steps+1])-100
price = sum(pay>0)/Npath
}
return(list(time = time, Y = Y, X = X, vol = vol, price = price))
}
sim.heston(sim.setup(Npath = 100000, Nsteps = 1000))
sim.setup(Npath = 100000, Nsteps = 1000)
sim.heston(sim.setup(Npath = 100000, Nsteps = 1000))
sim.heston(sim.setup())
sim.heston(sim.setup)
setting<-sim.setup()
sim.heston(setting)
setting$Npath
sim.heston<-function(settings){
N = settings$Npath
mat = settings$mat
steps = settings$Nsteps
kappa = settings$kappa
theta = settings$theta
xi = settings$xi       ##vol of vol
rho = settings$rho
gamma = settings$gamma
dt = mat/steps #dt is in years
time = 0:steps*dt
X = matrix(nrow = N, ncol = steps+1)
Y = matrix(nrow = N, ncol = steps+1)
vol = matrix(nrow = N, ncol = steps+1) #matrix if we want to save values along the way
call = numeric(N) # testing purpose
X[, 1] = 0
vol[, 1] = rgamma(N, 2*kappa*theta/xi^2, 2*kappa/xi^2)
Y[, 1] = X[,1] + gamma*sqrt(vol[,1])/sqrt(steps)*rnorm(N,0,1) #Changed from vol to sqrt(vol) /Seb 20.02.18
for(i in 2:(steps+1)){
NS = rnorm(N,0,1)
NV = rho*NS + sqrt(1-rho^2)*rnorm(N,0,1) #From StatÃ (Olivier) Theorem I.5 or Graphical example 1.20
#X[,i] =   X[,i-1] + X[,i-1]*sqrt(vol[,i-1])*sqrt(dt)*NS         #non-ln x's
X[,i] =   X[,i-1] + sqrt(vol[,i-1])*sqrt(dt)*NS
x = vol[,i-1] + kappa*(theta - vol[,i-1])*dt
y = sqrt(  log(  (xi^2*vol[,i-1]*dt)/(x^2) + 1  )  )
vol[, i] = x*exp(-0.5*y^2+y*NV  )
#Observed Y
omega = gamma*sqrt(vol[,i])/sqrt(steps)     # n corresponds to steps and not repetitions N? #should vol be i-1? No?
Y[,i] = X[,i] + omega * rnorm(N,0,1)
pay<-100*exp(X[,steps+1])-100
price = sum(pay>0)/N
}
return(list(time = time, Y = Y, X = X, vol = vol, price = price))
}
setting<-sim.setup()
setting$Npath
sim.heston(setting)
sim.heston<-function(settings){
N = settings$Npath
mat = settings$mat
steps = settings$Nsteps
kappa = settings$kappa
theta = settings$theta
xi = settings$xi       ##vol of vol
rho = settings$rho
gamma = settings$gamma
dt = mat/steps #dt is in years
time = 0:steps*dt
X = matrix(nrow = N, ncol = steps+1)
Y = matrix(nrow = N, ncol = steps+1)
vol = matrix(nrow = N, ncol = steps+1) #matrix if we want to save values along the way
call = numeric(N) # testing purpose
X[, 1] = 0
vol[, 1] = rgamma(N, 2*kappa*theta/xi^2, 2*kappa/xi^2)
Y[, 1] = X[,1] + gamma*sqrt(vol[,1])/sqrt(steps)*rnorm(N,0,1) #Changed from vol to sqrt(vol) /Seb 20.02.18
for(i in 2:(steps+1)){
NS = rnorm(N,0,1)
NV = rho*NS + sqrt(1-rho^2)*rnorm(N,0,1) #From StatÃ (Olivier) Theorem I.5 or Graphical example 1.20
#X[,i] =   X[,i-1] + X[,i-1]*sqrt(vol[,i-1])*sqrt(dt)*NS         #non-ln x's
X[,i] =   X[,i-1] + sqrt(vol[,i-1])*sqrt(dt)*NS
x = vol[,i-1] + kappa*(theta - vol[,i-1])*dt
y = sqrt(  log(  (xi^2*vol[,i-1]*dt)/(x^2) + 1  )  )
vol[, i] = x*exp(-0.5*y^2+y*NV  )
#Observed Y
omega = gamma*sqrt(vol[,i])/sqrt(steps)     # n corresponds to steps and not repetitions N? #should vol be i-1? No?
Y[,i] = X[,i] + omega * rnorm(N,0,1)
pay<-100*exp(X[,steps+1])-100
price = sum(pay[pay>0])/N
}
return(list(time = time, Y = Y, X = X, vol = vol, price = price))
}
setting<-sim.setup()
test<-sim.heston(setting)
test$price
setting<-sim.setup(theta = 1 )
setting
setting<-sim.setup(theta = 1, mat = 1 )
test<-sim.heston(setting)
test$price
test$price
test$price
sim.heston<-function(settings){
N = settings$Npath
mat = settings$mat
steps = settings$Nsteps
kappa = settings$kappa
theta = settings$theta
xi = settings$xi       ##vol of vol
rho = settings$rho
gamma = settings$gamma
dt = mat/steps #dt is in years
time = 0:steps*dt
X = matrix(nrow = N, ncol = steps+1)
Y = matrix(nrow = N, ncol = steps+1)
vol = matrix(nrow = N, ncol = steps+1) #matrix if we want to save values along the way
call = numeric(N) # testing purpose
X[, 1] = 0
vol[, 1] = rgamma(N, 2*kappa*theta/xi^2, 2*kappa/xi^2)
Y[, 1] = X[,1] + gamma*sqrt(vol[,1])/sqrt(steps)*rnorm(N,0,1) #Changed from vol to sqrt(vol) /Seb 20.02.18
for(i in 2:(steps+1)){
NS = rnorm(N,0,1)
NV = rho*NS + sqrt(1-rho^2)*rnorm(N,0,1) #From StatÃ (Olivier) Theorem I.5 or Graphical example 1.20
#X[,i] =   X[,i-1] + X[,i-1]*sqrt(vol[,i-1])*sqrt(dt)*NS         #non-ln x's
X[,i] =   X[,i-1] + sqrt(vol[,i-1])*sqrt(dt)*NS
x = vol[,i-1] + kappa*(theta - vol[,i-1])*dt
y = sqrt(  log(  (xi^2*vol[,i-1]*dt)/(x^2) + 1  )  )
vol[, i] = x*exp(-0.5*y^2+y*NV  )
#Observed Y
omega = gamma*sqrt(vol[,i])/sqrt(steps)     # n corresponds to steps and not repetitions N? #should vol be i-1? No?
Y[,i] = X[,i] + omega * rnorm(N,0,1)
pay<-100*exp(X[,steps+1]-1)-100
price = sum(pay[pay>0])/N
}
return(list(time = time, Y = Y, X = X, vol = vol, price = price))
}
setting<-sim.setup(theta = 1, mat = 1 )
test<-sim.heston(setting)
test$price
sim.heston<-function(settings){
N = settings$Npath
mat = settings$mat
steps = settings$Nsteps
kappa = settings$kappa
theta = settings$theta
xi = settings$xi       ##vol of vol
rho = settings$rho
gamma = settings$gamma
dt = mat/steps #dt is in years
time = 0:steps*dt
X = matrix(nrow = N, ncol = steps+1)
Y = matrix(nrow = N, ncol = steps+1)
vol = matrix(nrow = N, ncol = steps+1) #matrix if we want to save values along the way
call = numeric(N) # testing purpose
X[, 1] = 0
vol[, 1] = 1#rgamma(N, 2*kappa*theta/xi^2, 2*kappa/xi^2)
Y[, 1] = X[,1] + gamma*sqrt(vol[,1])/sqrt(steps)*rnorm(N,0,1) #Changed from vol to sqrt(vol) /Seb 20.02.18
for(i in 2:(steps+1)){
NS = rnorm(N,0,1)
NV = rho*NS + sqrt(1-rho^2)*rnorm(N,0,1) #From StatÃ (Olivier) Theorem I.5 or Graphical example 1.20
#X[,i] =   X[,i-1] + X[,i-1]*sqrt(vol[,i-1])*sqrt(dt)*NS         #non-ln x's
X[,i] =   X[,i-1] + sqrt(vol[,i-1])*sqrt(dt)*NS
x = vol[,i-1] + kappa*(theta - vol[,i-1])*dt
y = sqrt(  log(  (xi^2*vol[,i-1]*dt)/(x^2) + theta  )  )
vol[, i] = x*exp(-0.5*y^2+y*NV  )
#Observed Y
omega = gamma*sqrt(vol[,i])/sqrt(steps)     # n corresponds to steps and not repetitions N? #should vol be i-1? No?
Y[,i] = X[,i] + omega * rnorm(N,0,1)
pay<-100*exp(X[,steps+1])-100
price = sum(pay[pay>0])/N
}
return(list(time = time, Y = Y, X = X, vol = vol, price = price))
}
setting<-sim.setup(theta = 1, mat = 1 )
test<-sim.heston(setting)
test$price
sim.heston<-function(settings){
N = settings$Npath
mat = settings$mat
steps = settings$Nsteps
kappa = settings$kappa
theta = settings$theta
xi = settings$xi       ##vol of vol
rho = settings$rho
gamma = settings$gamma
dt = mat/steps #dt is in years
time = 0:steps*dt
X = matrix(nrow = N, ncol = steps+1)
Y = matrix(nrow = N, ncol = steps+1)
vol = matrix(nrow = N, ncol = steps+1) #matrix if we want to save values along the way
call = numeric(N) # testing purpose
X[, 1] = 100
vol[, 1] = rgamma(N, 2*kappa*theta/xi^2, 2*kappa/xi^2)
Y[, 1] = X[,1] + gamma*sqrt(vol[,1])/sqrt(steps)*rnorm(N,0,1) #Changed from vol to sqrt(vol) /Seb 20.02.18
for(i in 2:(steps+1)){
NS = rnorm(N,0,1)
NV = rho*NS + sqrt(1-rho^2)*rnorm(N,0,1) #From StatÃ (Olivier) Theorem I.5 or Graphical example 1.20
X[,i] =   X[,i-1] + X[,i-1]*sqrt(vol[,i-1])*sqrt(dt)*NS         #non-ln x's
#X[,i] =   X[,i-1] + sqrt(vol[,i-1])*sqrt(dt)*NS
x = vol[,i-1] + kappa*(theta - vol[,i-1])*dt
y = sqrt(  log(  (xi^2*vol[,i-1]*dt)/(x^2) + 1  )  )
vol[, i] = x*exp(-0.5*y^2+y*NV  )
#Observed Y
omega = gamma*sqrt(vol[,i])/sqrt(steps)     # n corresponds to steps and not repetitions N? #should vol be i-1? No?
Y[,i] = X[,i] + omega * rnorm(N,0,1)
#pay<-100*exp(X[,steps+1])-100
pay = X[,steps+1]-100
price = sum(pay[pay>0])/N
}
return(list(time = time, Y = Y, X = X, vol = vol, price = price))
}
setting<-sim.setup(theta = 1, mat = 1 )
test<-sim.heston(setting)
test$price
sim.heston<-function(settings){
N = settings$Npath
mat = settings$mat
steps = settings$Nsteps
kappa = settings$kappa
theta = settings$theta
xi = settings$xi       ##vol of vol
rho = settings$rho
gamma = settings$gamma
dt = mat/steps #dt is in years
time = 0:steps*dt
X = matrix(nrow = N, ncol = steps+1)
Y = matrix(nrow = N, ncol = steps+1)
vol = matrix(nrow = N, ncol = steps+1) #matrix if we want to save values along the way
call = numeric(N) # testing purpose
X[, 1] = log(100)
vol[, 1] = rgamma(N, 2*kappa*theta/xi^2, 2*kappa/xi^2)
Y[, 1] = X[,1] + gamma*sqrt(vol[,1])/sqrt(steps)*rnorm(N,0,1) #Changed from vol to sqrt(vol) /Seb 20.02.18
for(i in 2:(steps+1)){
NS = rnorm(N,0,1)
NV = rho*NS + sqrt(1-rho^2)*rnorm(N,0,1) #From StatÃ (Olivier) Theorem I.5 or Graphical example 1.20
X[,i] =   X[,i-1] + sqrt(vol[,i-1])*sqrt(dt)*NS         #non-ln x's
#X[,i] =   X[,i-1] + sqrt(vol[,i-1])*sqrt(dt)*NS
x = vol[,i-1] + kappa*(theta - vol[,i-1])*dt
y = sqrt(  log(  (xi^2*vol[,i-1]*dt)/(x^2) + 1  )  )
vol[, i] = x*exp(-0.5*y^2+y*NV  )
#Observed Y
omega = gamma*sqrt(vol[,i])/sqrt(steps)     # n corresponds to steps and not repetitions N? #should vol be i-1? No?
Y[,i] = X[,i] + omega * rnorm(N,0,1)
#pay<-100*exp(X[,steps+1])-100
pay = exp(X[,steps+1])-100
price = sum(pay[pay>0])/N
}
return(list(time = time, Y = Y, X = X, vol = vol, price = price))
}
setting<-sim.setup(theta = 1, mat = 1 )
test<-sim.heston(setting)
test$price
sim.heston<-function(settings){
N = settings$Npath
mat = settings$mat
steps = settings$Nsteps
kappa = settings$kappa
theta = settings$theta
xi = settings$xi       ##vol of vol
rho = settings$rho
gamma = settings$gamma
dt = mat/steps #dt is in years
time = 0:steps*dt
X = matrix(nrow = N, ncol = steps+1)
Y = matrix(nrow = N, ncol = steps+1)
vol = matrix(nrow = N, ncol = steps+1) #matrix if we want to save values along the way
call = numeric(N) # testing purpose
X[, 1] = log(100)
vol[, 1] = 1#rgamma(N, 2*kappa*theta/xi^2, 2*kappa/xi^2)
Y[, 1] = X[,1] + gamma*sqrt(vol[,1])/sqrt(steps)*rnorm(N,0,1) #Changed from vol to sqrt(vol) /Seb 20.02.18
for(i in 2:(steps+1)){
NS = rnorm(N,0,1)
NV = rho*NS + sqrt(1-rho^2)*rnorm(N,0,1) #From StatÃ (Olivier) Theorem I.5 or Graphical example 1.20
X[,i] =   X[,i-1] -1/2*vol[,i-1]*dt+ sqrt(vol[,i-1])*sqrt(dt)*NS         #non-ln x's
#X[,i] =   X[,i-1] + sqrt(vol[,i-1])*sqrt(dt)*NS
x = vol[,i-1] + kappa*(theta - vol[,i-1])*dt
y = sqrt(  log(  (xi^2*vol[,i-1]*dt)/(x^2) + 1  )  )
vol[, i] = x*exp(-0.5*y^2+y*NV  )
#Observed Y
omega = gamma*sqrt(vol[,i])/sqrt(steps)     # n corresponds to steps and not repetitions N? #should vol be i-1? No?
Y[,i] = X[,i] + omega * rnorm(N,0,1)
#pay<-100*exp(X[,steps+1])-100
pay = exp(X[,steps+1])-100
price = sum(pay[pay>0])/N
}
return(list(time = time, Y = Y, X = X, vol = vol, price = price))
}
setting<-sim.setup(theta = 1, mat = 1 )
test<-sim.heston(setting)
test$price
sim.heston<-function(settings){
N = settings$Npath
mat = settings$mat
steps = settings$Nsteps
kappa = settings$kappa
theta = settings$theta
xi = settings$xi       ##vol of vol
rho = settings$rho
gamma = settings$gamma
dt = mat/steps #dt is in years
time = 0:steps*dt
X = matrix(nrow = N, ncol = steps+1)
Y = matrix(nrow = N, ncol = steps+1)
vol = matrix(nrow = N, ncol = steps+1) #matrix if we want to save values along the way
call = numeric(N) # testing purpose
X[, 1] = log(100)
vol[, 1] = 1#rgamma(N, 2*kappa*theta/xi^2, 2*kappa/xi^2)
Y[, 1] = X[,1] + gamma*sqrt(vol[,1])/sqrt(steps)*rnorm(N,0,1) #Changed from vol to sqrt(vol) /Seb 20.02.18
for(i in 2:(steps+1)){
NS = rnorm(N,0,1)
NV = rho*NS + sqrt(1-rho^2)*rnorm(N,0,1) #From StatÃ (Olivier) Theorem I.5 or Graphical example 1.20
#X[,i] =   X[,i-1] -1/2*vol[,i-1]*dt+ sqrt(vol[,i-1])*sqrt(dt)*NS         # log
X[,i] =   X[,i-1] + X[,i-1]*sqrt(vol[,i-1])*sqrt(dt)*NS                 # non-log
#X[,i] =   X[,i-1] + sqrt(vol[,i-1])*sqrt(dt)*NS
x = vol[,i-1] + kappa*(theta - vol[,i-1])*dt
y = sqrt(  log(  (xi^2*vol[,i-1]*dt)/(x^2) + 1  )  )
vol[, i] = x*exp(-0.5*y^2+y*NV  )
#Observed Y
omega = gamma*sqrt(vol[,i])/sqrt(steps)     # n corresponds to steps and not repetitions N? #should vol be i-1? No?
Y[,i] = X[,i] + omega * rnorm(N,0,1)
#pay<-100*exp(X[,steps+1])-100
pay = X[, steps+1]-100
price = sum(pay[pay>0])/N
}
return(list(time = time, Y = Y, X = X, vol = vol, price = price))
}
setting<-sim.setup(theta = 1, mat = 1 )
test<-sim.heston(setting)
test$price
sim.heston<-function(settings){
N = settings$Npath
mat = settings$mat
steps = settings$Nsteps
kappa = settings$kappa
theta = settings$theta
xi = settings$xi       ##vol of vol
rho = settings$rho
gamma = settings$gamma
dt = mat/steps #dt is in years
time = 0:steps*dt
X = matrix(nrow = N, ncol = steps+1)
Y = matrix(nrow = N, ncol = steps+1)
vol = matrix(nrow = N, ncol = steps+1) #matrix if we want to save values along the way
call = numeric(N) # testing purpose
#X[, 1] = log(100)
X[, 1] = 100
vol[, 1] = 1#rgamma(N, 2*kappa*theta/xi^2, 2*kappa/xi^2)
Y[, 1] = X[,1] + gamma*sqrt(vol[,1])/sqrt(steps)*rnorm(N,0,1) #Changed from vol to sqrt(vol) /Seb 20.02.18
for(i in 2:(steps+1)){
NS = rnorm(N,0,1)
NV = rho*NS + sqrt(1-rho^2)*rnorm(N,0,1) #From StatÃ (Olivier) Theorem I.5 or Graphical example 1.20
#X[,i] =   X[,i-1] -1/2*vol[,i-1]*dt+ sqrt(vol[,i-1])*sqrt(dt)*NS         # log
X[,i] =   X[,i-1] + X[,i-1]*sqrt(vol[,i-1])*sqrt(dt)*NS                 # non-log
#X[,i] =   X[,i-1] + sqrt(vol[,i-1])*sqrt(dt)*NS
x = vol[,i-1] + kappa*(theta - vol[,i-1])*dt
y = sqrt(  log(  (xi^2*vol[,i-1]*dt)/(x^2) + 1  )  )
vol[, i] = x*exp(-0.5*y^2+y*NV  )
#Observed Y
omega = gamma*sqrt(vol[,i])/sqrt(steps)     # n corresponds to steps and not repetitions N? #should vol be i-1? No?
Y[,i] = X[,i] + omega * rnorm(N,0,1)
#pay<-100*exp(X[,steps+1])-100
pay = X[, steps+1]-100
price = sum(pay[pay>0])/N
}
return(list(time = time, Y = Y, X = X, vol = vol, price = price))
}
setting<-sim.setup(theta = 1, mat = 1 )
test<-sim.heston(setting)
test$price
setting<-sim.setup()
sim.heston<-function(settings){
N = settings$Npath
mat = settings$mat
steps = settings$Nsteps
kappa = settings$kappa
theta = settings$theta
xi = settings$xi       ##vol of vol
rho = settings$rho
gamma = settings$gamma
dt = mat/steps #dt is in years
time = 0:steps*dt
X = matrix(nrow = N, ncol = steps+1)
Y = matrix(nrow = N, ncol = steps+1)
vol = matrix(nrow = N, ncol = steps+1) #matrix if we want to save values along the way
call = numeric(N) # testing purpose
X[, 1] = 0
vol[, 1] = rgamma(N, 2*kappa*theta/xi^2, 2*kappa/xi^2)
Y[, 1] = X[,1] + gamma*sqrt(vol[,1])/sqrt(steps)*rnorm(N,0,1) #Changed from vol to sqrt(vol) /Seb 20.02.18
for(i in 2:(steps+1)){
NS = rnorm(N,0,1)
NV = rho*NS + sqrt(1-rho^2)*rnorm(N,0,1) #From StatÃ (Olivier) Theorem I.5 or Graphical example 1.20
#X[,i] =   X[,i-1] -1/2*vol[,i-1]*dt+ sqrt(vol[,i-1])*sqrt(dt)*NS        # real heston
#X[,i] =   X[,i-1] + X[,i-1]*sqrt(vol[,i-1])*sqrt(dt)*NS                 # non-log
X[,i] =   X[,i-1] + sqrt(vol[,i-1])*sqrt(dt)*NS                          # logs (driftless)
x = vol[,i-1] + kappa*(theta - vol[,i-1])*dt
y = sqrt(  log(  (xi^2*vol[,i-1]*dt)/(x^2) + 1  )  )
vol[, i] = x*exp(-0.5*y^2+y*NV  )
#Observed Y
omega = gamma*sqrt(vol[,i])/sqrt(steps)     # n corresponds to steps and not repetitions N? #should vol be i-1? No?
Y[,i] = X[,i] + omega * rnorm(N,0,1)
#pay<-100*exp(X[,steps+1])-100
#pay = X[, steps+1]-100
#price = sum(pay[pay>0])/N
}
return(list(time = time, Y = Y, X = X, vol = vol))
}
time = 0:(steps+1)/(steps+1)
0:(101)/(101)
(0:100)/100
source('C:/Users/Frederik/Dropbox/Lspeciale/masters-thesis/Simulation/Figur_1.R')
source('C:/Users/Frederik/Dropbox/Lspeciale/masters-thesis/Simulation/Figur_1.R')
library("ggplot2", lib.loc="~/R/win-library/3.3")
source('C:/Users/Frederik/Dropbox/Lspeciale/masters-thesis/Simulation/Figur_1.R')
ggplot(tmp, aes(x_akse, y_akse,color = rx)) +
geom_line() +
scale_color_manual("", values = c("black", "red", "blue")) +
xlab("time") + ylab("log-return")  +
#theme(legend.position = c(1,0),
#      legend.justification = c(1,0),
#      plot.title = element_text(hjust = 0.5, size = 20)) +
ggtitle("Log-return of asset") +
theme(plot.title = element_text(hjust = 0.5, size = 20))
source('C:/Users/Frederik/Dropbox/Lspeciale/masters-thesis/Simulation/Figur_1.R')
ggplot(tmp, aes(x_akse, y_akse,color = rx)) +
geom_line() +
scale_color_manual("", values = c("black", "red", "blue")) +
xlab("time") + ylab("log-return")  +
#theme(legend.position = c(1,0),
#      legend.justification = c(1,0),
#      plot.title = element_text(hjust = 0.5, size = 20)) +
ggtitle("Log-return of asset") +
theme(plot.title = element_text(hjust = 0.5, size = 20))
